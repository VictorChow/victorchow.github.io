---
layout: post
title: RocketMQ 的架构
date: 2020-08-05
categories: code
tags: MQ RocketMQ
typora-root-url: ../../victorchow.github.io
---

> 

## RocketMQ 是啥

![](/assets/img/20200805-1.png)

官方点说，RocketMQ 是一个统一的消息引擎、一个轻量级的数据处理平台

通俗点说，RocketMQ 是一个 **队列模型** 的消息中间件，具有**高性能、高可靠、高实时、分布式** 的特点

## RocketMQ 的模型

### 主题模型

在主题模型中，消息的生产者称为 **发布者(Publisher)** ，消息的消费者称为 **订阅者(Subscriber)** ，存放消息的容器称为 **主题(Topic)** ，发布者将消息发送到指定主题中，订阅者需要 **提前订阅主题** 才能接受特定主题的消息，通常的主题模型如下图：

![](/assets/img/20200805-2.svg)

### RocketMQ 的主题模型

![](/assets/img/20200805-3.svg)

* **Producer Group**

  生产者组，例如多个订单系统作为生产者，合在一起就是一个组 ，一般生产相同的消息

* **Topic**

  代表一类消息，例如订单消息等

* **Consumer Group**

  消费者组，例如多个短信系统作为消费者，合在一起就是一个组 ，一般消费相同的消息

生产者组中的生产者会向主题发送消息，而**主题中存在多个队列**，生产者每次生产消息之后是指定主题中的某个队列发送消息

每个主题中都有多个队列，集群消费模式下，一个消费者集群多台机器共同消费一个 `Topic` 的多个队列，**一个队列只会被一个消费者消费**。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 `Consumer1` 和 `Consumer2` 分别对应着两个队列，而 `Consuer3` 是没有队列对应的，所以一般来讲要控制**消费者组中的消费者个数和主题中队列个数相同** ，当然也可以消费者个数小于队列个数，只不过不太建议

**每个消费组在每个队列上都需要维护一个消费位置（offset）**

发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的，同一个消息被 A 消费组消费完后还会被 B 消费组消费，所以消息是不会删除的，仅仅是为每个消费者组维护一个 **消费位移（offset）** ，每次消费者组消费完以后队列把维护的消费位移 +1，这样就不会出现消息重复消费

![](/assets/img/20200805-4.svg)

**为什么一个主题中需要维护多个队列**

**提高并发能力**。按道理来说每个主题中只存在一个队列也是可行的，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，其实也可以做到发布订阅模式 ，但生产者只能向一个队列发送消息，一个消费者组中只能有一个消费者在消费，并发能力很小

所以 RocketMQ 通过使用在一个 Topic 中**配置多个队列并且每个队列维护每个消费者组的消费位置**实现了发布订阅模式

## RocketMQ 的架构

四大角色：`Broker` 、`NameServer` 、`Producer` 、`Consumer`

* ### Broker

  消息队列服务器，主要负责消息的存储、投递和查询以及服务高可用保证，生产者生产消息到 `Broker` ，消费者从 `Broker` 拉取消息并消费

#### Broker 、Topic 和队列的关系

一个 `Topic` 可以分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，是多对多的关系

如果某个 `Topic` 消息量很大，可以多配置几个队列，提高并发能力，并且**尽量多分布在不同`Broker` 上，以减轻某个 `Broker` 的压力** ，`Topic` 消息量都比较均匀的情况下，如果某个 `broker` 上的队列越多，则该 `broker` 压力越大

![](/assets/img/20200805-5.svg)

* ### NameServer

  注册中心，类似于`Eureka`或者`Consul`，负责**Broker管理**和**路由信息管理**，`Broker` 会将自己的信息注册到 `NameServer` 中，此时 `NameServer` 就存放了很多 `Broker` 的信息（Broker的路由表），消费者和生产者就从 `NameServer` 中获取路由表然后照着路由表的信息和对应的 `Broker` 进行通信（生产者和消费者定期会向 `NameServer` 去查询相关的 `Broker` 的信息）

* ### Producer

  生产者，支持分布式集群方式部署

* ### Consumer

  消费者，支持分布式集群方式部署

#### 四者关系图如下

![](/assets/img/20200805-6.svg)

 `Broker` 是需要保证高可用的，如果整个系统仅仅靠着一个 `Broker` 来维持的话，那么这个 `Broker` 的压力会很大，所以我们需要使用多个 `Broker` 来保证 **负载均衡** 

如果说，我们的消费者和生产者直接和多个 `Broker` 相连，那么当 `Broker` 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 `NameServer` 注册中心就是用来解决这个问题的

#### 官网的架构图如下

![](/assets/img/20200805-7.jpg)

*  `Broker` **做了集群并且还进行了主从部署** ，由于消息分布在各个 `Broker` 上，一旦某个 `Broker` 宕机，则该`Broker` 上的消息读写都会受到影响， `RocketMQ` 提供了 `master/slave` 的结构，` salve` 定时从 `master` 同步数据（同步刷盘或者异步刷盘），如果 `master` 宕机，**则 `slave` 提供消费服务，但是不能写入消息**

* 为了保证 `高可用性（HA）` ， `NameServer` 也做了集群部署，它是 **去中心化** 的，没有主节点， `NameServer` 的所有节点是没有进行 `Info Replicate` 的，**单个 Broker 和所有 NameServer 保持长连接** ，并且在每隔30秒 `Broker` 会向所有 `Nameserver` 发送心跳，心跳包含了自身的 `Topic` 配置信息，这个步骤就对应这上面的 `Routing Info` 

* 在生产者需要向 `Broker` 发送消息的时候，**需要先从 `NameServer` 获取关于 `Broker` 的路由信息**，然后通过 **轮询** 的方法去向每个队列中生产数据以达到 **负载均衡** 的效果

* 消费者通过 `NameServer` 获取所有 `Broker` 的路由信息后，向 `Broker` 发送 `Pull` 请求来获取消息数据

  `Consumer` 可以以**广播（Broadcast）和集群（Cluster）**两种方式启动。广播模式下，一条消息会发送给 **同一个消费组中的所有消费者** ，集群模式下消息只会发送给 **一个** 消费者

## 鸣谢

[消息队列扫盲](https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/RocketMQ.md) 👍