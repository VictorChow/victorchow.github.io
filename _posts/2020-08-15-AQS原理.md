---
layout: post
title: Java çš„ AQS åŸç†
date: 2020-08-15
categories: code
tags: Java
typora-root-url: ../../victorchow.github.io
---

> ä¸€ä¸ªç”¨æ¥å®ç°åŒæ­¥é”ä»¥åŠå…¶ä»–æ¶‰åŠåˆ°åŒæ­¥åŠŸèƒ½çš„æ ¸å¿ƒç»„ä»¶

AQS å…¨ç§°ä¸º AbstractQueuedSynchronizerï¼Œä½äº java.util.concurrent.locks åŒ…ä¸‹ï¼Œä½œè€…æ˜¯è‘—åçš„å¹¶å‘åŒ…å¤§ç¥ [Doug Lea](https://baike.baidu.com/item/Doug%20Lea/6319404?fr=aladdin)ï¼ˆjava.util.concurrent ä¸‹çš„ç±»åŸºæœ¬éƒ½æ˜¯ä»–å†™çš„ï¼‰ï¼ŒAQS æä¾›äº†ä¸€ä¸ª FIFO é˜Ÿåˆ—ï¼Œç”¨æ¥æ„å»ºé”å’ŒåŒæ­¥å™¨ã€‚

## AQS çš„èµ„æºå…±äº«æ–¹å¼

- ç‹¬å é”ï¼ˆ**Exclusive**ï¼‰ï¼Œæ¯æ¬¡åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œ**ReentrantLock**
- å…±äº«é”ï¼ˆ**Share**ï¼‰ï¼Œå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è·å–é”ï¼Œå¹¶å‘è®¿é—®å…±äº«èµ„æºï¼Œ**ReentrantReadWriteLock**

## AQS çš„åŸç†

**AQS æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œå¦‚æœè¢«è¯·æ±‚çš„å…±äº«èµ„æºç©ºé—²ï¼Œåˆ™å°†å½“å‰è¯·æ±‚èµ„æºçš„çº¿ç¨‹è®¾ç½®ä¸ºæœ‰æ•ˆçš„å·¥ä½œçº¿ç¨‹ï¼Œå¹¶ä¸”å°†å…±äº«èµ„æºè®¾ç½®ä¸ºé”å®šçŠ¶æ€ã€‚å¦‚æœè¢«è¯·æ±‚çš„å…±äº«èµ„æºè¢«å ç”¨ï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸€å¥—çº¿ç¨‹é˜»å¡ç­‰å¾…ä»¥åŠè¢«å”¤é†’æ—¶é”åˆ†é…çš„æœºåˆ¶ï¼Œè¿™ä¸ªæœºåˆ¶ AQS æ˜¯ç”¨ CLH é˜Ÿåˆ—é”å®ç°çš„ï¼Œå³å°†æš‚æ—¶è·å–ä¸åˆ°é”çš„çº¿ç¨‹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚**

> CLHï¼ˆCraig,Landin,and Hagerstenï¼‰é˜Ÿåˆ—æ˜¯ä¸€ä¸ªè™šæ‹Ÿçš„åŒå‘é˜Ÿåˆ—ï¼ˆè™šæ‹Ÿçš„åŒå‘é˜Ÿåˆ—å³ä¸å­˜åœ¨é˜Ÿåˆ—å®ä¾‹ï¼Œä»…å­˜åœ¨ç»“ç‚¹ä¹‹é—´çš„å…³è”å…³ç³»ï¼‰ï¼ŒAQS æ˜¯å°†æ¯æ¡è¯·æ±‚å…±äº«èµ„æºçš„çº¿ç¨‹å°è£…æˆä¸€ä¸ª CLH é”é˜Ÿåˆ—çš„ä¸€ä¸ª Node æ¥å®ç°é”çš„åˆ†é…ã€‚

![](/assets/img/20200815-1.svg)

AQS ä½¿ç”¨ä¸€ä¸ª int å˜é‡ state æ¥è¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼Œé€šè¿‡é˜Ÿåˆ—æ¥å®Œæˆè·å–èµ„æºçº¿ç¨‹çš„æ’é˜Ÿå·¥ä½œï¼ŒAQS ä½¿ç”¨ CAS å¯¹è¯¥åŒæ­¥çŠ¶æ€è¿›è¡ŒåŸå­æ“ä½œå®ç°å¯¹å…¶å€¼çš„ä¿®æ”¹ã€‚

```java
/**
* The synchronization state.
*/
private volatile int state;
```

ä¸ state ç›¸å…³çš„æ–¹æ³•ï¼š

```java
/**
 * Returns the current value of synchronization state.
 * This operation has memory semantics of a {@code volatile} read.
 * @return current state value
 */
protected final int getState() {
    return state;
}

/**
 * Sets the value of synchronization state.
 * This operation has memory semantics of a {@code volatile} write.
 * @param newState the new state value
 */
protected final void setState(int newState) {
    state = newState;
}

/**
 * Atomically sets synchronization state to the given updated
 * value if the current state value equals the expected value.
 * This operation has memory semantics of a {@code volatile} read
 * and write.
 *
 * @param expect the expected value
 * @param update the new value
 * @return {@code true} if successful. False return indicates that the actual
 *         value was not equal to the expected value.
 */
protected final boolean compareAndSetState(int expect, int update) {
    return STATE.compareAndSet(this, expect, update);
}
```

### ç‹¬å é”ï¼ˆExclusiveï¼‰å’Œå…±äº«é”ï¼ˆShareï¼‰

* #### Exclusive

  ä»¥ **ReentrantLock** ä¸ºä¾‹ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æ‰§è¡Œï¼Œåˆå¯åˆ†ä¸ºå…¬å¹³é”å’Œéå…¬å¹³é”ï¼Œéå…¬å¹³é”ä¼šæœ‰æ›´å¥½çš„æ€§èƒ½ã€‚

  > å…¬å¹³é”ï¼šæŒ‰ç…§çº¿ç¨‹åœ¨é˜Ÿåˆ—ä¸­çš„æ’é˜Ÿé¡ºåºï¼Œå…ˆåˆ°è€…å…ˆæ‹¿åˆ°é”
  >
  > éå…¬å¹³é”ï¼šå½“çº¿ç¨‹è¦è·å–é”æ—¶ï¼Œå…ˆé€šè¿‡ä¸¤æ¬¡ CAS æ“ä½œå»æŠ¢é”ï¼Œå¦‚æœæ²¡æŠ¢åˆ°ï¼Œå½“å‰çº¿ç¨‹å†åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ç­‰å¾…å”¤é†’

  **ReentrantLock** é»˜è®¤é‡‡ç”¨éå…¬å¹³é”ï¼Œé€šè¿‡æ„é€ å‡½æ•°ä¼ å…¥ boolean æ¥å†³å®šæ˜¯å¦ç”¨å…¬å¹³é”ã€‚

  ```java
  /** Synchronizer providing all implementation mechanics */
  private final Sync sync;
  
  /**
   * Creates an instance of {@code ReentrantLock}.
   * This is equivalent to using {@code ReentrantLock(false)}.
   */
  public ReentrantLock() {
      sync = new NonfairSync();
  }
  
  /**
   * Creates an instance of {@code ReentrantLock} with the
   * given fairness policy.
   *
   * @param fair {@code true} if this lock should use a fair ordering policy
   */
  public ReentrantLock(boolean fair) {
      sync = fair ? new FairSync() : new NonfairSync();
  }
  ```

  **ReentrantLock** ä¸­å…¬å¹³é”çš„ lock æ–¹æ³•ï¼š

  ```java
  static final class FairSync extends Sync {
      final void lock() {
          acquire(1);
      }
      // AbstractQueuedSynchronizer.acquire(int arg)
      public final void acquire(int arg) {
          if (!tryAcquire(arg) &&
              acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
              selfInterrupt();
      }
      protected final boolean tryAcquire(int acquires) {
          final Thread current = Thread.currentThread();
          int c = getState();
          if (c == 0) {
              // 1. å’Œéå…¬å¹³é”ç›¸æ¯”ï¼Œè¿™é‡Œå¤šäº†ä¸€ä¸ªåˆ¤æ–­ï¼šæ˜¯å¦æœ‰çº¿ç¨‹åœ¨ç­‰å¾…
              if (!hasQueuedPredecessors() &&
                  compareAndSetState(0, acquires)) {
                  setExclusiveOwnerThread(current);
                  return true;
              }
          }
          else if (current == getExclusiveOwnerThread()) {
              int nextc = c + acquires;
              if (nextc < 0)
                  throw new Error("Maximum lock count exceeded");
              setState(nextc);
              return true;
          }
          return false;
      }
  }
  ```

  **ReentrantLock** ä¸­éå…¬å¹³é”çš„ lock æ–¹æ³•ï¼š

  ```java
  static final class NonfairSync extends Sync {
      final void lock() {
          // 2. å’Œå…¬å¹³é”ç›¸æ¯”ï¼Œè¿™é‡Œä¼šç›´æ¥å…ˆè¿›è¡Œä¸€æ¬¡CASï¼ŒæˆåŠŸå°±è¿”å›äº†
          if (compareAndSetState(0, 1))
              setExclusiveOwnerThread(Thread.currentThread());
          else
              acquire(1);
      }
      // AbstractQueuedSynchronizer.acquire(int arg)
      public final void acquire(int arg) {
          if (!tryAcquire(arg) &&
              acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
              selfInterrupt();
      }
      protected final boolean tryAcquire(int acquires) {
          return nonfairTryAcquire(acquires);
      }
  }
  /**
   * Performs non-fair tryLock.  tryAcquire is implemented in
   * subclasses, but both need nonfair try for trylock method.
   */
  final boolean nonfairTryAcquire(int acquires) {
      final Thread current = Thread.currentThread();
      int c = getState();
      if (c == 0) {
          // è¿™é‡Œæ²¡æœ‰å¯¹é˜»å¡é˜Ÿåˆ—è¿›è¡Œåˆ¤æ–­
          if (compareAndSetState(0, acquires)) {
              setExclusiveOwnerThread(current);
              return true;
          }
      }
      else if (current == getExclusiveOwnerThread()) {
          int nextc = c + acquires;
          if (nextc < 0) // overflow
              throw new Error("Maximum lock count exceeded");
          setState(nextc);
          return true;
      }
      return false;
  }
  ```

  å…¬å¹³é”å’Œéå…¬å¹³é”ä¸åŒä¹‹å¤„ï¼š

  1. éå…¬å¹³é”åœ¨è°ƒç”¨ lock åï¼Œé¦–å…ˆå°±ä¼šè°ƒç”¨ CAS è¿›è¡Œä¸€æ¬¡æŠ¢é”ï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™æ°å·§é”æ²¡æœ‰è¢«å ç”¨ï¼Œé‚£ä¹ˆç›´æ¥å°±è·å–åˆ°é”è¿”å›äº†
  2. éå…¬å¹³é”åœ¨ CAS å¤±è´¥åï¼Œå’Œå…¬å¹³é”ä¸€æ ·éƒ½ä¼šè¿›å…¥åˆ° tryAcquire æ–¹æ³•ï¼Œåœ¨ tryAcquire æ–¹æ³•ä¸­ï¼Œå¦‚æœå‘ç°é”è¿™ä¸ªæ—¶å€™è¢«é‡Šæ”¾äº†ï¼ˆstate == 0ï¼‰ï¼Œéå…¬å¹³é”ä¼šç›´æ¥ CAS æŠ¢é”ï¼Œä½†æ˜¯å…¬å¹³é”ä¼šåˆ¤æ–­ç­‰å¾…é˜Ÿåˆ—æ˜¯å¦æœ‰çº¿ç¨‹å¤„äºç­‰å¾…çŠ¶æ€ï¼Œå¦‚æœæœ‰åˆ™ä¸å»æŠ¢é”ï¼Œè‡ªåŠ¨æ’åˆ°åé¢

  å¦‚æœè¿™ä¸¤æ¬¡ CAS éƒ½ä¸æˆåŠŸï¼Œé‚£ä¹ˆåé¢éå…¬å¹³é”å’Œå…¬å¹³é”æ˜¯ä¸€æ ·çš„ï¼Œéƒ½è¦è¿›å…¥åˆ°é˜»å¡é˜Ÿåˆ—ç­‰å¾…å”¤é†’ã€‚

  ç›¸å¯¹æ¥è¯´ï¼Œéå…¬å¹³é”ä¼šæœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºå®ƒçš„ååé‡æ¯”è¾ƒå¤§ã€‚å½“ç„¶ï¼Œéå…¬å¹³é”è®©è·å–é”çš„æ—¶é—´å˜å¾—æ›´åŠ ä¸ç¡®å®šï¼Œå¯èƒ½ä¼šå¯¼è‡´åœ¨é˜»å¡é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹é•¿æœŸå¤„äºé¥¥é¥¿çŠ¶æ€ã€‚

* #### Share

  å¤šä¸ªçº¿ç¨‹å¯åŒæ—¶æ‰§è¡Œã€‚**ReentrantReadWriteLock** è¯»å†™é”å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹æŸä¸€èµ„æºè¿›è¡Œè¯»ã€‚

  ä¸åŒçš„è‡ªå®šä¹‰åŒæ­¥å™¨äº‰ç”¨å…±äº«èµ„æºçš„æ–¹å¼ä¹Ÿä¸åŒã€‚è‡ªå®šä¹‰åŒæ­¥å™¨åœ¨å®ç°æ—¶åªéœ€è¦å®ç°å…±äº«èµ„æº state çš„è·å–ä¸é‡Šæ”¾æ–¹å¼å³å¯ï¼Œè‡³äºå…·ä½“çº¿ç¨‹ç­‰å¾…é˜Ÿåˆ—çš„ç»´æŠ¤ï¼ˆå¦‚è·å–èµ„æºå¤±è´¥å…¥é˜Ÿ/å”¤é†’å‡ºé˜Ÿç­‰ï¼‰ï¼ŒAQS å·²ç»åœ¨ä¸Šå±‚å·²ç»å¸®æˆ‘ä»¬å®ç°å¥½äº†ã€‚

## AQS çš„æ¨¡æ¿æ–¹æ³•æ¨¡å¼

åŒæ­¥å™¨çš„è®¾è®¡æ˜¯åŸºäºæ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„ï¼Œå¦‚æœéœ€è¦è‡ªå®šä¹‰åŒæ­¥å™¨ä¸€èˆ¬çš„æ–¹å¼æ˜¯ï¼š

1. ä½¿ç”¨è€…ç»§æ‰¿ AbstractQueuedSynchronizer å¹¶é‡å†™æŒ‡å®šçš„æ–¹æ³•
2. å°† AQS ç»„åˆåœ¨è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶çš„å®ç°ä¸­ï¼Œå¹¶è°ƒç”¨å…¶æ¨¡æ¿æ–¹æ³•ï¼Œè€Œè¿™äº›æ¨¡æ¿æ–¹æ³•ä¼šè°ƒç”¨ä½¿ç”¨è€…é‡å†™çš„æ–¹æ³•

è‡ªå®šä¹‰åŒæ­¥å™¨éœ€è¦é‡å†™ä¸‹é¢å‡ ä¸ª AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼š

```java
/**
 * è¯¥çº¿ç¨‹æ˜¯å¦æ­£åœ¨ç‹¬å èµ„æºï¼Œåªæœ‰ç”¨åˆ°conditionæ‰éœ€è¦å»å®ç°å®ƒã€‚
 */
protected boolean isHeldExclusively();

/**
 * ç‹¬å æ–¹å¼ã€‚å°è¯•è·å–èµ„æºï¼ŒæˆåŠŸåˆ™è¿”å›trueï¼Œå¤±è´¥åˆ™è¿”å›falseã€‚
 */
protected boolean tryAcquire(int arg);
  
/**
 * ç‹¬å æ–¹å¼ã€‚å°è¯•é‡Šæ”¾èµ„æºï¼ŒæˆåŠŸåˆ™è¿”å›trueï¼Œå¤±è´¥åˆ™è¿”å›falseã€‚
 */
protected boolean tryRelease(int arg);
  
/**
 * å…±äº«æ–¹å¼ã€‚å°è¯•è·å–èµ„æºã€‚
 * è´Ÿæ•°è¡¨ç¤ºå¤±è´¥ï¼›0è¡¨ç¤ºæˆåŠŸï¼Œä½†æ²¡æœ‰å‰©ä½™å¯ç”¨èµ„æºï¼›æ­£æ•°è¡¨ç¤ºæˆåŠŸï¼Œä¸”æœ‰å‰©ä½™èµ„æºã€‚
 */
protected int tryAcquireShared(int arg);
  
/**
 * å…±äº«æ–¹å¼ã€‚å°è¯•é‡Šæ”¾èµ„æºï¼ŒæˆåŠŸåˆ™è¿”å›trueï¼Œå¤±è´¥åˆ™è¿”å›falseã€‚
 */
protected boolean tryReleaseShared(int arg);
```

ä»¥ **ReentrantLock** ä¸ºä¾‹ï¼Œstate åˆå§‹åŒ–ä¸º 0ï¼Œè¡¨ç¤ºæœªé”å®šçŠ¶æ€ã€‚A çº¿ç¨‹ lock() æ—¶ï¼Œä¼šè°ƒç”¨ tryAcquire() ç‹¬å è¯¥é”å¹¶å°† state+1ã€‚æ­¤åï¼Œå…¶ä»–çº¿ç¨‹å† tryAcquire() æ—¶å°±ä¼šå¤±è´¥ï¼Œç›´åˆ° A çº¿ç¨‹ unlock() åˆ° state=0ï¼ˆå³é‡Šæ”¾é”ï¼‰ä¸ºæ­¢ï¼Œå…¶å®ƒçº¿ç¨‹æ‰æœ‰æœºä¼šè·å–è¯¥é”ã€‚å½“ç„¶ï¼Œé‡Šæ”¾é”ä¹‹å‰ï¼ŒA çº¿ç¨‹è‡ªå·±æ˜¯å¯ä»¥é‡å¤è·å–æ­¤é”çš„ï¼ˆstate ä¼šç´¯åŠ ï¼‰ï¼Œè¿™å°±æ˜¯å¯é‡å…¥çš„æ¦‚å¿µã€‚ä½†è¦æ³¨æ„ï¼Œè·å–å¤šå°‘æ¬¡å°±è¦é‡Šæ”¾å¤šä¹ˆæ¬¡ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯ state æ˜¯èƒ½å›åˆ° 0 çš„ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œè‡ªå®šä¹‰åŒæ­¥å™¨è¦ä¹ˆæ˜¯ç‹¬å æ–¹æ³•ï¼Œè¦ä¹ˆæ˜¯å…±äº«æ–¹å¼ï¼Œä»–ä»¬ä¹Ÿåªéœ€å®ç°`tryAcquire-tryRelease`ã€`tryAcquireShared-tryReleaseShared`ä¸­çš„ä¸€ç§å³å¯ã€‚

ä½† AQS ä¹Ÿæ”¯æŒè‡ªå®šä¹‰åŒæ­¥å™¨åŒæ—¶å®ç°ç‹¬å å’Œå…±äº«ä¸¤ç§æ–¹å¼ï¼Œå¦‚`ReentrantReadWriteLock`ã€‚

## ğŸ’ é¸£è°¢

[AQS åŸç†ä»¥åŠ AQS åŒæ­¥ç»„ä»¶æ€»ç»“](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md)

[ä¸€è¡Œä¸€è¡Œæºç åˆ†ææ¸…æ¥š AbstractQueuedSynchronizer](https://www.javadoop.com/post/AbstractQueuedSynchronizer-2)