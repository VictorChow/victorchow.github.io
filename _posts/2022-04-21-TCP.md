---
layout: post
title: TCP 的三次握手、四次挥手
date: 2022-04-21
categories: code
tags: TCP
typora-root-url: ../../victorchow.github.io
---

> 『不就是打个电话吗？』

## 三次握手

![20220421-1](/assets/img/20220421-1.svg)

* ### 第一次握手

  客户端发、服务端收，服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的

* ### 第二次握手

  服务端发、客户端收，客户端就能得出结论：服务端的接收、发送能力和客户端的接收、发送能力是正常的

* ### 第三次握手

  客户端发、服务端收，服务端就能得出结论：客户端的接收、发送能力和服务端的发送、接收能力是正常的

> **张三：**李四你好啊，我是张三，能听到我说话吗？**（SYN_SENT）**
>
> **李四：**张三你好啊，我是李四，我能听到你说话，你能听到我说话吗？**（SYN_RCVD）**
>
> **张三：**李四你好啊，我能听见你说话，我们开始快乐的PY交易吧！**（ESTAB）**

## 四次挥手

![20220421-2](/assets/img/20220421-2.svg)

* ### 第一次挥手

  发起端发起挥手请求，向接收端发送标志位是 FIN 报文段，发起端端进入`FIN_WAIT_1`状态，这表示发起端没有数据要发送给接收端了

* ### 第二次挥手

  接收端收到了发起端发送的FIN报文段，向发起端返回一个标志位是 ACK 的报文段，发起端进入`FIN_WAIT_2`状态，接收端告诉发起端确认关闭请求，但此时接收端可能还会有数据传输

* ### 第三次挥手

  接收端向发起端发送标志位是 FIN 的报文段，请求关闭连接，同时发起端进入`LAST_ACK`状态

* ### 第四次挥手

  发起端收到接收端发送的 FIN 报文段，然后发起端进入`TIME_WAIT`状态。接收端收到发起端的ACK报文段以后就关闭连接。此时发起端等待 **2MSL** 的时间后依然没有收到回复，则证明接收端已正常关闭，发起端也关闭连接

> **张三：**先不说了啊，有事要挂了！**（FIN_WAIT_1）**
>
> **李四：**OK！稍等一小会，我想想还有没有事和你说！**（CLOSE_WAIT）**
>
> **张三：**...**（FIN_WAIT_2）**
>
> **李四：**好了，没有啥要说的了，我要挂了啊！**（LAST_ACK）**
>
> **张三：**OK！你先挂吧！**（TIME_WAIT）**
>
> **李四（挂了电话）：** **（CLOSED）**
>
> **张三（缓了一会神挂了电话）：** **（CLOSED）**

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

### 为什么要等待 2MSL:

- **保证 TCP 协议的全双工连接能够可靠关闭**：

  由于 IP 协议的不可靠性或者是其它网络原因，导致了接收端没有收到发起端的ACK报文，那么接收端就会在超时之后重新发送 FIN，如果此时发起端的连接已经关闭处于`CLOESD`状态，那么重发的 FIN 就找不到对应的连接了，从而导致连接错乱，所以，发起端发送完最后的 ACK 不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到 FIN 的收，能够保证对方收到 ACK，最后正确关闭连接。

- **保证这次连接的重复数据段从网络中消失**

  如果发起端发送最后的 ACK 直接进入`CLOSED`状态，然后又再向接收端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达发起端，由于新老连接的端口号和IP都一样，TCP 协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以 TCP 连接需要在 `TIME_WAIT`状态等待 2MSL，才能保证本次连接的所有数据在网络中消失。

